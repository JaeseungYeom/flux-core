flux_rpc(3)
===========
:doctype: manpage


NAME
----
flux_rpc, flux_rpcf, flux_rpc_raw, flux_rpc_get, flux_rpc_getf, flux_rpc_get_raw - perform a remote procedure call to a Flux service


SYNOPSIS
--------
 #include <flux/core.h>

 flux_future_t *flux_rpc (flux_t *h, const char *topic,
                          const char *json_str,
                          uint32_t nodeid, int flags);

 flux_future_t *flux_rpcf (flux_t *h, const char *topic,
                           uint32_t nodeid, int flags,
                           const char *fmt, ...);

 flux_future_t *flux_rpc_raw (flux_t *h, const char *topic,
                              const void *data, int len,
                              uint32_t nodeid, int flags);

 int flux_rpc_get (flux_future_t *f, const char **json_str);

 int flux_rpc_getf (flux_future_t *f, const char *fmt, ...);

 int flux_rpc_get_raw (flux_future_t *f, void *data, int *len);


DESCRIPTION
-----------

A remote procedure call (RPC) consists of a matched request and
response message exchanged with a Flux service.  `flux_rpc()`,
`flux_rpcf()`, and `flux_rpc_raw()` encode and send a request message
via Flux broker handle _h_ to a Flux service identified by _topic_
and _nodeid_.  A `flux_future_t` object is returned which acts as a handle
for synchronization and a container for the response message which in
turn contains the RPC result.

`flux_future_then(3)` may be used to register a reactor callback
(continuation) to be called once the response has been received.
`flux_future_wait_for(3)` may be used to block until the
response has been received.  Both accept an optional timeout.

`flux_rpc_get()`, `flux_rpc_getf()`, and `flux_rpc_get_raw()`
decode the RPC result.  Internally, they call `flux_future_get()`
to access the response message stored in the future.  If the response
message has not yet been received, these functions block until it is,
or an error occurs.


REQUEST OPTIONS
---------------

The request message is encoded and sent with or without a payload
using one of the three `flux_rpc()` variants.

`flux_rpc()` attaches _json_str_, a serialized JSON string, as request
payload.  If NULL, the request is encoded without a payload.

`flux_rpcf()` attaches a JSON payload encoded using Jansson `json_pack()`
style arguments (see below).

`flux_rpc_raw()` attaches a raw payload _data_ of length _len_, in bytes.
If _data_ is NULL, the request is encoded without a payload.

_nodeid_ affects request routing, and must be set to one of the following
values:

FLUX_NODEID_ANY::
The request is routed to the first matching service instance.

FLUX_NODEID_UPSTREAM::
The request is routed to the first matching service instance,
skipping over the sending rank.

integer::
The request is routed to a specific rank.

_flags_ may be zero or:

FLUX_RPC_NORESPONSE::
No response is expected.  The request will not be assigned a matchtag,
and the returned flux_future_t is immediately fulfilled, and may simply
be destroyed.

RESPONSE OPTIONS
----------------

The response message is stored in the future when the future is fulfilled.
At that time it is decoded with `flux_response_decode(3)`.  If it cannot
be decoded, or if the service returned an error, the future is fulfilled
with an error.  Otherwise it is fulfilled with the response message.
If there was an error, `flux_future_get()` or the `flux_rpc_get()` variants
return an error.

`flux_rpc_get()` sets _json_str_ (if non-NULL) to the serialized JSON
payload contained in the RPC response.  If there was no payload, _json_str_
is set to NULL.

`flux_rpc_getf()` decodes the JSON payload using Jansson `json_unpack()` style
arguments (see below).  It is an error if there is no payload, or if the
payload is not JSON.

`flux_rpc_get_raw()` assigns the raw payload of the RPC response message
to _data_ and its length to _len_.  If there is no payload, this function
will fail.


include::JSON_PACK.adoc[]


include::JSON_UNPACK.adoc[]


CANCELLATION
------------

Flux RFC 6 does not currently specify a cancellation protocol for an
individual RPC, but does stipulate that an RPC may be canceled if a disconnect
message is received, as is automatically generated by the local connector
upon client disconnection.

If `flux_future_destroy()` is called before a response is received, a
matchtag value from the handle _h_'s matchtag pool is leaked.
If enough matchtags are leaked, it will be impossible to make RPC calls
on that handle.


RETURN VALUE
------------

`flux_rpc()`, `flux_rpcf()`, and `flux_rpc_raw()` return a flux_future_t
object on success.  On error, NULL is returned, and errno is set appropriately.

`flux_rpc_get()`, `flux_rpc_getf()`, and `flux_rpc_get_raw()` returns zero on
success.  On error, -1 is returned, and errno is set appropriately.


ERRORS
------

ENOSYS::
Handle has no send operation.

EINVAL::
Some arguments were invalid.

EPROTO::
A protocol error was encountered.


EXAMPLES
--------

This example performs a synchronous RPC with the broker's "attr.get"
service to obtain the broker's rank.

....
include::trpc.c[]
....

This example registers a continuation to do the same thing asynchronously.

....
include::trpc_then.c[]
....


AUTHOR
------
This page is maintained by the Flux community.


RESOURCES
---------
Github: <http://github.com/flux-framework>


COPYRIGHT
---------
include::COPYRIGHT.adoc[]


SEE ALSO
---------
flux_future_then(3)

https://github.com/flux-framework/rfc/blob/master/spec_6.adoc[RFC 6: Flux
Remote Procedure Call Protocol]
